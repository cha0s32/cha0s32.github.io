<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>呆毛的博客</title><link>https:/cha0s32.github.io</link><description>童话是一种生活态度，仅此而已。</description><copyright>呆毛的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cos.kevinc.ltd/file/download?fileId=1420</url><title>avatar</title><link>https:/cha0s32.github.io</link></image><lastBuildDate>Mon, 11 Dec 2023 02:18:24 +0000</lastBuildDate><managingEditor>呆毛的博客</managingEditor><pubDate>Mon, 11 Dec 2023 02:18:24 +0000</pubDate><ttl>60</ttl><webMaster>呆毛的博客</webMaster><item><title>Docker 入门笔记</title><link>https:/cha0s32.github.io/post/Docker%20-ru-men-bi-ji.html</link><description>&#13;
# 启程&#13;
&#13;
## 容器生态系统&#13;
&#13;
生态系统： 核心技术、平台技术和支持技术&#13;
&#13;
容器核心技术：让Container在host运行起来的那些技术&#13;
&#13;
- 容器规范&#13;
&#13;
```bash&#13;
组织： Open Container Initiative (OCI)&#13;
&#13;
发布两个规范： runtime spec 和 image format spec&#13;
&#13;
（1） runtime 为容器提供运行环境， docker 和 runtime 的关系类比 Java 和 JVM 的 关系&#13;
&#13;
		lxc runc rkt 是目前主流的三种容器 runtime&#13;
&#13;
（2） 容器管理工具&#13;
&#13;
	对内与 runtime 交互， 对外提供用户接口 （CLI）&#13;
&#13;
（3） 容器定义工具&#13;
&#13;
	docker image 容器的模版&#13;
	dockerfile 用于创建docker image&#13;
	ACI 与image类似，不过是CoreOS开发的&#13;
&#13;
（5） Registry&#13;
&#13;
	镜像的仓库&#13;
  有Docker Hub 和 Quay.io&#13;
&#13;
（6） 容器OS&#13;
&#13;
	专门用于运行容器的操作系统&#13;
```&#13;
&#13;
容器平台技术：使容器作为集群在分布式环境中运行&#13;
&#13;
包括容器编排引擎、容器管理平台、基于容器的PaaS&#13;
&#13;
## docker 镜像&#13;
&#13;
### base 镜像&#13;
&#13;
含义：&#13;
&#13;
- 不依赖其他镜像，从scratch构建&#13;
- 其他镜像可以以之为基础进行扩展&#13;
&#13;
Linux 操作系统 由内核空间和用户空间 组成&#13;
&#13;
对于base 镜像来说，底层直接用 Host 的 kernal，自己只需要提供 rootfs 就行了&#13;
&#13;
base镜像用户空间和发行版一致，内核版本由Docker Host 决定，所有容器共用host的内核&#13;
&#13;
### 镜像的分层结构&#13;
&#13;
新镜像是从base镜像一层层叠加生成，每安装一个软件，就在现有镜像的基础上增加一层&#13;
&#13;
如果有多个镜像由同一个base镜像构建而来，那docker host 只需要在内存中记载一份base镜像，就可以为所有容器提供服务&#13;
&#13;
镜像的每一层都可以被共享&#13;
&#13;
**可写的容器层**：当容器启动的时候，会有一个可写层加载到镜像顶部。</description><guid isPermaLink="true">https:/cha0s32.github.io/post/Docker%20-ru-men-bi-ji.html</guid><pubDate>Mon, 11 Dec 2023 02:16:59 +0000</pubDate></item><item><title>Git从入门到实操</title><link>https:/cha0s32.github.io/post/Git-cong-ru-men-dao-shi-cao.html</link><description>## Git 基础&#13;
&#13;
&#13;
&#13;
### 创建版本库&#13;
&#13;
```shell&#13;
git init &#13;
```&#13;
&#13;
### 添加及提交到仓库&#13;
&#13;
```shell&#13;
git add xxx.file&#13;
git commit -m "xxxx"&#13;
&#13;
## 看看工作区和暂存区的区别&#13;
git diff xxx.file&#13;
```&#13;
&#13;
### 版本回退&#13;
&#13;
```shell&#13;
# 查看最近三次commit 记录&#13;
&#13;
git log --pretty=oneline&#13;
```&#13;
&#13;
HEAD 表示当前版本， HEAD^ 表示上一个版本， HEAD～100表示前100个版本&#13;
&#13;
```shell&#13;
git reset --hard HEAD^ # 回退到上一个版本&#13;
```&#13;
&#13;
Git在内部有个指向当前版本的`HEAD`指针，当你回退版本的时候，Git仅仅是把HEAD从指向指定版本&#13;
&#13;
想从旧版本恢复到新版本，但是新版本的`commit id`用`git log`找不到了：&#13;
&#13;
```shell&#13;
git reflog&#13;
```&#13;
&#13;
可以看到每一步HEAD指针的变更记录，从而找到新版本的`commit id`&#13;
&#13;
```shell&#13;
git reset --hard commit_id&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
### 撤销修改&#13;
&#13;
```shell&#13;
git checkout -- file_name&#13;
```&#13;
&#13;
- 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态&#13;
- 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态&#13;
&#13;
&#13;
&#13;
如果修改已经提交到暂存区了，使用`git reset HEAD file_name`可以把暂存区的修改撤销掉，重新放回工作区&#13;
&#13;
然后再`git reset -- file_name`把工作区的文件还原&#13;
&#13;
&#13;
&#13;
### 远程仓库&#13;
&#13;
第一步，在 github上创建远程仓库&#13;
&#13;
本地文件夹关联远程仓库 （origin也可以改成其他的）&#13;
&#13;
```shell&#13;
git remote add origin git@github.com:cha0s32/xxx.git&#13;
```&#13;
&#13;
第一次把本地内容推送到远程仓库&#13;
&#13;
```shell&#13;
git push -u origin master # -u 会把本地master分支和远程master分支关联起来&#13;
```&#13;
&#13;
查看远程库信息&#13;
&#13;
```shell&#13;
git remote -v&#13;
```&#13;
&#13;
接触远程库和本地的绑定关系&#13;
&#13;
```shell&#13;
git remote rm 远程库的名字&#13;
```&#13;
&#13;
&#13;
&#13;
从远程库上克隆项目&#13;
&#13;
```shell&#13;
# ssh&#13;
&#13;
git clone git@github.com:cha0s32/xxx.git&#13;
&#13;
# https&#13;
https://github.com/cha0s32/xxx.git # 比较慢&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
## 分支管理&#13;
&#13;
### 创建与合并分支&#13;
&#13;
```shell&#13;
git checkout -b dev # 创建名为dev的分支,并切换过去&#13;
# git switch -c dev&#13;
```&#13;
&#13;
改动 dev 分支的文件，然后提交&#13;
&#13;
```shell&#13;
git add .&#13;
git commit -m "a new branch"&#13;
```&#13;
&#13;
切换回master分支&#13;
&#13;
```shell&#13;
git branch master # git switch master&#13;
```&#13;
&#13;
合并 dev 分支&#13;
&#13;
```shell&#13;
git merge dev&#13;
```&#13;
&#13;
删除 dev 分支&#13;
&#13;
```shell&#13;
git branch -d dev&#13;
```&#13;
&#13;
&#13;
&#13;
### 解决冲突&#13;
&#13;
当两个分支同时改动同一个文件，并且都提交了以后，要 merge 需要手工解决冲突&#13;
&#13;
新建新分支&#13;
&#13;
```shell&#13;
git switch -c test&#13;
```&#13;
&#13;
原 master 中有一个 readme 文件，内容为 &#13;
&#13;
```shell&#13;
aaaaaaaa&#13;
bbbbbbbb&#13;
```&#13;
&#13;
且已提交&#13;
&#13;
新分支中，也有readme文件，内容为&#13;
&#13;
```shell&#13;
aaaaaaaaa&#13;
bbbbbbbba&#13;
```&#13;
&#13;
也已提交，现打算在主分支用`git merge`合并，会出现冲突的提示，使用`cat readme`可以看到两个文件的区别&#13;
&#13;
在主分支的`readme`中作改动，然后再次提交，解决冲突&#13;
&#13;
```shell&#13;
git add .&#13;
git commit -m "conflict commit"&#13;
```&#13;
&#13;
然后可以删掉 `test`分支&#13;
&#13;
&#13;
&#13;
### 分支管理策略&#13;
&#13;
通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。</description><guid isPermaLink="true">https:/cha0s32.github.io/post/Git-cong-ru-men-dao-shi-cao.html</guid><pubDate>Thu, 07 Dec 2023 09:57:33 +0000</pubDate></item><item><title>一次排序注入的研究</title><link>https:/cha0s32.github.io/post/yi-ci-pai-xu-zhu-ru-de-yan-jiu.html</link><description>最近看到一个大佬的渗透报告，里面有一个排序注入的利用。</description><guid isPermaLink="true">https:/cha0s32.github.io/post/yi-ci-pai-xu-zhu-ru-de-yan-jiu.html</guid><pubDate>Thu, 07 Dec 2023 03:10:59 +0000</pubDate></item></channel></rss>